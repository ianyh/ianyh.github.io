<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Bias and Sandwiches]]></title>
  <link href="http://ianyh.com/atom.xml" rel="self"/>
  <link href="http://ianyh.com/"/>
  <updated>2015-04-17T22:06:57-04:00</updated>
  <id>http://ianyh.com/</id>
  <author>
    <name><![CDATA[Ian Ynda-Hummel]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Identifying Spaces in Mac OS X]]></title>
    <link href="http://ianyh.com/blog/2013/09/24/identifying-spaces-in-mac-os-x/"/>
    <updated>2013-09-24T22:42:00-04:00</updated>
    <id>http://ianyh.com/blog/2013/09/24/identifying-spaces-in-mac-os-x</id>
    <content type="html"><![CDATA[<p>I recently implemented a featured in <a href="http://ianyh.com/amethyst/">Amethyst</a> that
allowed every space to have its own unique set of resources. In implementing
this feature I ran into a problem: how do you determine which space you're
currently on?</p>

<p>One might think that this would be a sensible piece of information to expose,
but alas and alack it is hidden behind private APIs. So what is a
tiling-window-management-inclined programmer to do? Dig into a bunch of weird
pieces of public information. The first being the preferences of spaces itself.</p>

<!--more-->


<h1>Preferences on OS X</h1>

<p>The first piece of information to know is how preferences work. Here's a
lightning overview. You may be familiar with <code>NSUserDefaults</code>. It is used to
store application preferences. By default it accesses the application's
preferences, which are backed by a file in <code>~/Library/Preferences</code> named using
your application's bundle identifier. Amethyst, for example, has a file at
<code>~/Library/Preferences/com.amethyst.Amethyst.plist</code>.</p>

<p>Additionally, <code>NSUserDefaults</code> has an interesting method
<code>-[NSUserDefaults addSuiteNamed:]</code>, which takes a single argument called
<code>suiteName</code>. From the docs</p>

<blockquote><p>The suiteName domain is similar to a bundle identifier string, but is not tied
to a particular application or bundle. A suite can be used to hold preferences
that are shared between multiple applications.</p></blockquote>

<p>How does this help us? Well, you can look for yourself and note that
<code>~/Library/Preferences/com.apple.spaces.plist</code> exists. You can read that file
using the <code>defaults</code> command.</p>

<pre><code class="bash">$ defaults read com.apple.spaces
</code></pre>

<p>There's a whole bunch of data. And if you try
<code>[[NSUserDefaults standardUserDefaults] addSuiteNamed:@"com.apple.spaces"]</code> you
will indeed have access to all of that data. Progress!</p>

<h1>Spaces Preferences</h1>

<p>So let's dig into what's actually in the preferences. There's a list of spaces:</p>

<pre><code class="objective-c">Spaces =                     (
   {
      id64 = 4;
      pid =                             (
         48173,
         218
      );
      type = 2;
      uuid = dashboard;
   },
   {
      id64 = 3;
      type = 0;
      uuid = "";
      wsid = 1;
   },
   {
      id64 = 5;
      type = 0;
      uuid = "B8E129CC-DDDF-44D9-A583-6DE0FB39319E";
   },
   {
      id64 = 7;
      type = 0;
      uuid = "21359712-DBFB-40AA-BAB5-87D1DDC6D442";
   },
   {
      id64 = 6;
      type = 0;
      uuid = "956AEFA7-387D-463D-A90B-341E2137644A";
   },
   {
      id64 = 8;
      type = 0;
      uuid = "599C0154-A9E1-4FD4-9489-54212240B3AE";
   }
)
</code></pre>

<p>Great. They've got uuids! We can use those as identifiers. And if we look
closely there seems to even be a specific preference for the current space!</p>

<pre><code class="objective-c">"Current Space" =                     {
   id64 = 3;
   type = 0;
   uuid = "";
   wsid = 1;
};
</code></pre>

<p>Now just to confirm you can switch to a different space and read the defaults
again and get:</p>

<pre><code class="objective-c">"Current Space" =                     {
   id64 = 3;
   type = 0;
   uuid = "";
   wsid = 1;
};
</code></pre>

<p>Wait. The <code>uuid</code> didn't change at all. What the hell? Okay, well, it's not going
to be that easy. So let's look at something else. There's a list of windows in
each space, that's promising.</p>

<p>Here's an excerpt of what it looks like on my machine right now for one of my
spaces:</p>

<pre><code class="objective-c">{
   name = "";
   windows =                 (
      70,
      101,
      102,
      14747,
      48
   );
}
</code></pre>

<p>Okay, so we've got a name which seems to be the space's uuid and a list of
window numbers. That's useful. Maybe we can find the window numbers on the
current space and use that to match up to a space identifier. So let's take a
look at windows and window numbers.</p>

<h1>Windows Of The Current Space</h1>

<p>It turns out there is a public API for accessing all of the windows on the
current space. It is done using the method</p>

<pre><code class="objective-c">CFArrayRef CGWindowListCopyWindowInfo(CGWindowListOption option, CGWindowID relativeToWindow);
</code></pre>

<p>The options for <code>option</code> are</p>

<pre><code class="objective-c">enum
{
   kCGWindowListOptionAll                 = 0,
   kCGWindowListOptionOnScreenOnly        = (1 &lt;&lt; 0),
   kCGWindowListOptionOnScreenAboveWindow = (1 &lt;&lt; 1),
   kCGWindowListOptionOnScreenBelowWindow = (1 &lt;&lt; 2),
   kCGWindowListOptionIncludingWindow     = (1 &lt;&lt; 3),
   kCGWindowListExcludeDesktopElements    = (1 &lt;&lt; 4)
}
</code></pre>

<p>We can not specify a <code>relativeToWindow</code> ID and use the option
<code>kCGWindowListOptionOnScreenOnly</code> to get all windows that are on the screen
right now. That means all the windows in the current space, as any other windows
are not on screen.</p>

<p>It gives you a bunch of dictionaries that look like</p>

<pre><code class="objective-c">{
   kCGWindowAlpha = 1;
   kCGWindowBounds =         {
      Height = 22;
      Width = 212;
      X = 1662;
      Y = 0;
   };
   kCGWindowIsOnscreen = 1;
   kCGWindowLayer = 25;
   kCGWindowMemoryUsage = 30104;
   kCGWindowName = "";
   kCGWindowNumber = 14;
   kCGWindowOwnerName = SystemUIServer;
   kCGWindowOwnerPID = 99;
   kCGWindowSharingState = 1;
   kCGWindowStoreType = 2;
}
</code></pre>

<p>which conveniently has a window number under the key <code>kCGWindowNumber</code>.</p>

<h1>Putting It All Together</h1>

<p>Okay, so we can get a list of windows connected to space uuids and we can get a
list of windows on the current space. We should be able to cross-reference the
lists to figure out the uuid of the current space. Great.</p>

<p>But there's one subtle problem here. Windows can be on many spaces. So we have
to make sure to ignore any windows on more than one space.</p>

<p>The final code looks like:</p>

<pre><code class="objective-c">- (NSString *)activeSpaceIdentifier {
    [[NSUserDefaults standardUserDefaults] removeSuiteNamed:@"com.apple.spaces"];
    [[NSUserDefaults standardUserDefaults] addSuiteNamed:@"com.apple.spaces"];

    NSArray *spaceProperties = [[NSUserDefaults standardUserDefaults] dictionaryForKey:@"SpacesConfiguration"][@"Space Properties"];
    NSMutableDictionary *spaceIdentifiersByWindowNumber = [NSMutableDictionary dictionary];
    for (NSDictionary *spaceDictionary in spaceProperties) {
        NSArray *windows = spaceDictionary[@"windows"];
        for (NSNumber *window in windows) {
            if (spaceIdentifiersByWindowNumber[window]) {
                spaceIdentifiersByWindowNumber[window] = [spaceIdentifiersByWindowNumber[window] arrayByAddingObject:spaceDictionary[@"name"]];
            } else {
                spaceIdentifiersByWindowNumber[window] = @[ spaceDictionary[@"name"] ];
            }
        }
    }

    CFArrayRef windowDescriptions = CGWindowListCopyWindowInfo(kCGWindowListOptionOnScreenOnly, kCGNullWindowID);
    NSString *activeSpaceIdentifier = nil;

    for (NSDictionary *dictionary in (__bridge NSArray *)windowDescriptions) {
        NSNumber *windowNumber = dictionary[(__bridge NSString *)kCGWindowNumber];
        NSArray *spaceIdentifiers = spaceIdentifiersByWindowNumber[windowNumber];

        if (spaceIdentifiers.count == 1) {
            activeSpaceIdentifier = spaceIdentifiers[0];
            break;
        }
    }

    CFRelease(windowDescriptions);

    return activeSpaceIdentifier;
}
</code></pre>

<p>But wait! What if there's no windows in a space? Well, it turns out that unless
you're doing something really weird there's always <em>something</em> in every space
because the system has a bunch of hidden windows you never see. If you're doing
something really weird and you actually encounter a space with no windows in it
I would love to hear about it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Amethyst 0.8.1]]></title>
    <link href="http://ianyh.com/blog/2013/09/23/amethyst-0-dot-8-1/"/>
    <updated>2013-09-23T15:25:00-04:00</updated>
    <id>http://ianyh.com/blog/2013/09/23/amethyst-0-dot-8-1</id>
    <content type="html"><![CDATA[<p>Released <a href="http://ianyh.com/amethyst">Amethyst</a> version 0.8.1 yesterday. I
figured out some significant improvements to its interactions with
spaces. Moving windows between spaces would occasionally fail due to an
unfortunate race condition. That's been fixed. On top of that, each space now
has its own set of layouts so no need to switch layouts and reset layout
parameters all the time when jumping between spaces.</p>

<p>You can download it directly
<a href="http://ianyh.com/amethyst/versions/Amethyst-0.8.1.zip">here</a> or install via
<a href="https://github.com/phinze/homebrew-cask">homebrew cask</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Amethyst 0.8]]></title>
    <link href="http://ianyh.com/blog/2013/08/19/amethyst-0-dot-8/"/>
    <updated>2013-08-19T16:43:00-04:00</updated>
    <id>http://ianyh.com/blog/2013/08/19/amethyst-0-dot-8</id>
    <content type="html"><![CDATA[<p>Released Amethyst version 0.8 yesterday. It has some significant improvements to
stability as well as adding a few new features. There's a new column layout that
tiles windows into full height columns and the addition of floating windows. It
can be downloaded <a href="http://ianyh.com/Amethyst/versions/Amethyst-0.8.zip">here</a> or
installed via <a href="https://github.com/phinze/homebrew-cask">homebrew cask</a>.</p>

<!--more-->


<h1>Floating Windows</h1>

<p>I had a request for floating windows and it's now in the app. <code>mod1 + t</code> can be
used to toggle whether a window is tiled or floating. A floating window will not
be tiled, but will be part of the focus chain.</p>

<p>Additionally, you can supply a list of bundle identifiers for which windows will
be floating by default. They can be specified by defining an array of bundle
identifier strings under the <code>floating</code> key in your <code>.amethyst</code> file. Any
application matching a bundle identifier in the list will have its windows float
by default, though use of <code>mod1 + t</code> will tile it if you want. I find this quite
useful for windows that Amethyst generally can't resize or position correctly
(e.g., Photoshop).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Accessibility, Windows, and Spaces in OS X]]></title>
    <link href="http://ianyh.com/blog/2013/06/05/accessibility/"/>
    <updated>2013-06-05T09:58:00-04:00</updated>
    <id>http://ianyh.com/blog/2013/06/05/accessibility</id>
    <content type="html"><![CDATA[<p>A couple weeks ago I decided to sit down and write a tiling window manager. As a
first and second pass it pretty much works, though there's definitely room for
improvement. I'm calling it <a href="https://github.com/ianyh/Amethyst">Amethyst</a>. (It's
a kind of quartz, you see. Get it? <em>Get it</em>?)</p>

<p>The first pass dealt with multiple screens fairly well as I was implementing it
at a desk with multiple screens and managing windows across screen is a simple
matter of position. It wasn't until I started trying it out on my laptop that I
realized that Spaces support was fairly key. There's just not enough room on
this 13" screen. I spent a long time digging into moving windows between spaces
and have some insights I couldn't find anywhere else and I thought I'd share
them here.</p>

<!--more-->


<h1>Spaces API</h1>

<p>It used to be the case that there was a public API for moving windows between
spaces. They went private in 10.7, I think. There's a couple projects around
that utilize the private APIs, but I didn't want to go that route. For one thing
it might be nice to toss something into the AppStore, but it's mostly a
stability problem in that I don't want to have to go back and entirely
reimplement parts of the code due to radically shifting private APIs.</p>

<p>In my searching I dug into a variety of possible paths. I eventually came upon a
fascinating tidbit of information.</p>

<blockquote><p>If the mouse has hold of a window, switching to a Space via Mission Control
will take the window to that Space.</p></blockquote>

<p>Intriguing! You can test it out if you like. Works like a charm when you do it
manually. So how do we do it programmatically? Well, we manually post keyboard
and mouse events!</p>

<h1>CGEvents</h1>

<p>A quick overview of how <code>CGEvent</code> works. My use of it is mostly centered around
the following method:</p>

<pre><code class="objective-c">void CGEventPost(CGEventTapLocation tap, CGEventRef event)
</code></pre>

<p>This allows you to post events directly to the window server. Great. So that
should let us post mouse events and keyboard events. So let's take a look at the
parameters.</p>

<p>The first is the tap location, of which there are three possible values:</p>

<pre><code class="objective-c">enum _CGEventTapLocation {
   kCGHIDEventTap = 0,
   kCGSessionEventTap,
   kCGAnnotatedSessionEventTap
};
</code></pre>

<p><code>kCGHIDEventTap</code> is the one we want. From the documentation:</p>

<blockquote><p>Specifies that an event tap is placed at the point where HID system events
enter the window server.</p></blockquote>

<p><code>kCGSessionEventTap</code> includes remote control events and stuff, and
<code>kCGAnnotatedSessionEventTap</code> is for sending events to specific applications.</p>

<p>The second parameter is a <code>CGEventRef</code>, which describes things like keyboard
modifier flags, mouse button, mouse state, mouse position, keyboard key codes,
etc. There are a variety of methods that can be used to create <code>CGEvent</code>
objects. The two we care about are <code>CGEventCreateMouseEvent</code> and
<code>CGEventCreateKeyboardEvent</code>.</p>

<h2>CGEventCreateMouseEvent</h2>

<pre><code class="objective-c">CGEventRef CGEventCreateMouseEvent(CGEventSourceRef source, CGEventType mouseType, CGPoint mouseCursorPosition, CGMouseButton mouseButton);
</code></pre>

<p>As the name implies this method is used to create mouse events. <code>source</code> is
basically meaningless for our purposes as it used for generating new events from
existing ones. <code>mouseCursorPosition</code> is pretty straightforward. It's the the
point on the screen that the mouse event should happen at.</p>

<p>There are a bunch of <code>CGEventType</code> values, which themselves are just proxies for
values buried deep in the HID system. The ones we care about for mouse events
are:</p>

<pre><code class="objective-c">enum {
  ...
  kCGEventLeftMouseDown = NX_LMOUSEDOWN,
  kCGEventLeftMouseUp = NX_LMOUSEUP,
  kCGEventMouseMoved = NX_MOUSEMOVED,
  ...
}
</code></pre>

<p>There are a couple <code>CGMouseButton</code> values as well:</p>

<pre><code class="objective-c">enum {
  kCGMouseButtonLeft = 0,
  kCGMouseButtonRight = 1,
  kCGMouseButtonCenter = 2
};
</code></pre>

<p>To simulate a standard tap we just want <code>kCGMouseButtonLeft</code>. To actually
simulate a tap we can do something like</p>

<pre><code class="objective-c">CGPoint point = { .x = 0, .y = 0 };
CGEventRef mouseMoveEvent = CGEventCreateMouseEvent(NULL, kCGEventMouseMoved, point, kCGMouseButtonLeft);
CGEventRef mouseDownEvent = CGEventCreateMouseEvent(NULL, kCGEventLeftMouseDown, point, kCGMouseButtonLeft);
CGEventRef mouseUpEvent = CGEventCreateMouseEvent(NULL, kCGEventLeftMouseUp, point, kCGMouseButtonLeft);

CGEventPost(mouseMoveEvent);
CGEventPost(mouseDownEvent);
CGEventPost(mouseUpEvent);

CFRelease(mouseMoveEvent);
CFRelease(mouseDownEvent);
CFRelease(mouseUpEvent);
</code></pre>

<p>to simulate a tap at (0, 0). Cool. Let's look at keyboard events.</p>

<h2>CGEventCreateKeyboardEvent</h2>

<pre><code class="objective-c">CGEventRef CGEventCreateKeyboardEvent(CGEventSourceRef source, CGKeyCode virtualKey, bool keyDown);
</code></pre>

<p><code>source</code> is about as useful here as it was for mouse events, and hopefully
<code>keyDown</code> is self explanatory. The important thing to note is that to perform a
keypress we actually need two events: one for <code>keyDown = true</code> followed by one
for <code>keyDown = false</code>.</p>

<p><code>virtualKey</code> can probably take its values from a variety of places. I went with
the virtual keycodes defined in the Carbon framework. It's
<code>Carbon.framework/Frameworks/HIToolbox.framework/Events.h</code> if you want to look
them up. Repeating them all here isn't particularly useful.</p>

<p>So let's say we want to perform the standard keyboard shortcut for moving one
space to the right (^ + Right Arrow). We could do</p>

<pre><code class="objective-c">CGEventRef keyboardDownEvent = CGEventCreateKeyboardEvent(NULL, kVK_RightArrow, true);
CGEventRef keyboardUpEvent = CGEventCreateKeyboardEvent(NULL, kVK_RightArrow, false);

CGEventPost(keyboardDownEvent);
CGEventPost(keyboardUpEvent);

CFRelease(keyboardDownEvent);
CFRelease(keyboardUpEvent);
</code></pre>

<p>But wait, what about the control key? Well, there's a method for that.</p>

<pre><code class="objective-c">void CGEventSetFlags(CGEventRef event, CGEventFlags flags);
</code></pre>

<p>Where <code>flags</code> is some OR'd combination of possible flag values. The ones we care
about here are</p>

<pre><code class="objective-c">enum {
  /* Device-independent modifier key bits. */
  kCGEventFlagMaskAlphaShift =          NX_ALPHASHIFTMASK,
  kCGEventFlagMaskShift =               NX_SHIFTMASK,
  kCGEventFlagMaskControl =             NX_CONTROLMASK,
  kCGEventFlagMaskAlternate =           NX_ALTERNATEMASK,
  kCGEventFlagMaskCommand =             NX_COMMANDMASK,
  ...
};
</code></pre>

<p>So to fix the keyboard event code from above.</p>

<pre><code class="objective-c">CGEventRef keyboardDownEvent = CGEventCreateKeyboardEvent(NULL, kVK_RightArrow, true);
CGEventRef keyboardUpEvent = CGEventCreateKeyboardEvent(NULL, kVK_RightArrow, false);

CGEventSetFlags(keyboardDownEvent, kCGEventFlagMaskControl);

CGEventPost(keyboardDownEvent);
CGEventPost(keyboardUpEvent);

CFRelease(keyboardDownEvent);
CFRelease(keyboardUpEvent);
</code></pre>

<h2>Putting It All Together</h2>

<p>So let's say you have an accessibility reference to a window and want to move it
to a different space. There's an important question you need to answer first: at
what point do you move the mouse to grab the window? Conceptually the answer is
pretty straightforward. You move the mouse to the window's toolbar. In practice
there's a couple unintuitive gotchas.</p>

<p>My initial intuition for this was to take the min-y and mid-x of the window's
frame, so the cursor ends up in the middle of the window's toolbar. Should work
fine, should work with every window. But when I implemented that it would fail
for some windows, namely Xcode. As best I can tell the middle of Xcode's toolbar
as depicted below is grabbing mouse down events for something.</p>

<p><img src="/images/2013-05-29-accessibility/xcode-toolbar.png" alt="toolbar" /></p>

<p>Okay, so what other point on the x-axis do all windows have in common? That
little green zoom button!</p>

<h2>But Wait, What About Modifiers?</h2>

<p>There is one more point to consider. We are going to be executing this operation
from an event handler triggered by a keyboard shortcut. Let's take an example
shortcut <code>ctrl + option + right arrow</code> for taking the currently focused window
and moving it one space right. You hit this keyboard shortcut and we go and
create events and post them. There's a gotcha here. <code>CGEvent</code> create methods
<em>start with the current modifiers unless otherwise specified</em>. Depending on the
timing we could accidentally create a <code>ctrl + click</code> event instead of just a
<code>click</code> event. Most windows don't care, but Xcode (why is it always Xcode?)
does. We need to thus make sure that we clear out any modifier flags on keyboard
and mouse events that we don't expect to have any modifiers.</p>

<h2>The Final Method</h2>

<p>To avoid unnecessary details of the accessibility API the following code uses an
<code>NSObject</code> wrapper.</p>

<pre><code class="objective-c">AMAccessibilityElement *windowElement = [self window];
AMAccessibilityElement *zoomButtonElement = [windowElement elementForKey:kAXZoomButtonAttribute];
CGRect zoomButtonFrame = zoomButtonElement.frame;
CGRect windowFrame = windowElement.frame;

CGPoint mouseCursorPoint = { .x = CGRectGetMaxX(zoomButtonFrame) + 5.0, .y = windowFrame.origin.y + 5.0 };

CGEventRef mouseMoveEvent = CGEventCreateMouseEvent(NULL, kCGEventMouseMoved, mouseCursorPoint, kCGMouseButtonLeft);
CGEventRef mouseDownEvent = CGEventCreateMouseEvent(NULL, kCGEventLeftMouseDown, mouseCursorPoint, kCGMouseButtonLeft);
CGEventRef mouseUpEvent = CGEventCreateMouseEvent(NULL, kCGEventLeftMouseUp, mouseCursorPoint, kCGMouseButtonLeft);

CGEventRef keyboardDownEvent = CGEventCreateKeyboardEvent(NULL, kVK_RightArrow, true);
CGEventRef keyboardUpEvent = CGEventCreateKeyboardEvent(NULL, kVK_RightArrow, false);

CGEventSetFlags(mouseMoveEvent, 0);
CGEventSetFlags(mouseDownEvent, 0);
CGEventSetFlags(mouseUpEvent, 0);
CGEventSetFlags(keyboardDownEvent, kCGEventFlagMaskControl);
CGEventSetFlags(keyboardUpEvent, 0);

CGEventPost(kCGHIDEventTap, mouseMoveEvent);
CGEventPost(kCGHIDEventTap, mouseDownEvent);
CGEventPost(kCGHIDEventTap, keyboardDownEvent);
CGEventPost(kCGHIDEventTap, keyboardUpEvent);
CGEventPost(kCGHIDEventTap, mouseUpEvent);

CFRelease(mouseMoveEvent);
CFRelease(mouseDownEvent);
CFRelease(mouseUpEvent);
CFRelease(keyboardEvent);
CFRelease(keyboardEventUp);                         
</code></pre>
]]></content>
  </entry>
  
</feed>
